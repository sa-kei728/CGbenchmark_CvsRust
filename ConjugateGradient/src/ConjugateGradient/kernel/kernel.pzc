#include "pzc_builtin.h"

static int get_global_id(int)
{
	return get_pid()*get_maxtid() + get_tid();
}

static constexpr auto THREADS = ::size_t(16384);

// 疎行列・ベクトル積 y = A x
void pzc_SpMV(
	double y[],
	const double data[],
	const ulong column[],
	const ulong nonzero[],
	const ulong maxNonzero,
	const double x[],
	         const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		double y_i = 0;
		const ulong nnz = nonzero[i];
		for(ulong idx = 0; idx < nnz; ++idx)
		{
			const double a_ij = data[i*maxNonzero + idx];
			const ulong j = column[i*maxNonzero + idx];
			const double x_j = x[j];
			const double ax = a_ij * x_j;
			y_i += ax;
		}

		y[i] = y_i;
	}
	flush();
}

// ベクトルの加算y += αx
void pzc_AddAlpha(double y[], const double alpha, const double x[], const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		const double x_i = x[i];
		      double y_i = y[i];
		y_i += alpha * x_i;
		y[i] = y_i;
	}
	flush();
}

// ベクトルの加算y = x + βy
void pzc_AddBeta(double y[], const double x[], const double beta, const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		const double x_i = x[i];
		      double y_i = y[i];
		y_i = x_i + beta * y_i;
		y[i] = y_i;
	}
	flush();
}

// ベクトルの引き算z = x - y
void pzc_Sub(double z[], const double x[], const double y[], const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		const double x_i = x[i];
		const double y_i = y[i];
		const double z_i = x_i - y_i;
		z[i] = z_i;
	}
	flush();
}

// ベクトルの要素積z = x*y
void pzc_Mul(double z[], const double x[], const double y[], const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		const double x_i = x[i];
		const double y_i = y[i];
		const double z_i = x_i * y_i;
		z[i] = z_i;
	}
	flush();
}

// ベクトルの要素二乗z = x*x
void pzc_Square(double z[], const double x[], const ulong n)
{
	for(int i = get_global_id(0); i < n; i += THREADS)
	{
		const double x_i = x[i];
		const double z_i = x_i * x_i;
		z[i] = z_i;
	}
	flush();
}

// 総和計算（リダクション）
void pzc_Sum(double z[], const ulong n, const ulong m)
{
	for(int i = get_global_id(0); i < m; i += THREADS)
	{
		const double left  = z[i];
		const double right = (i + m < n) ? z[i + m] : 0; // 範囲外の場合は0を足す
		const double z_i = left + right;
		z[i] = z_i;
	}
	flush();
}
